# model.py
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.base import BaseEstimator, RegressorMixin
import pandas as pd
class PyTorchMLPRegressor(BaseEstimator, RegressorMixin):
    def __init__(self, hidden_layer_sizes=(100,), activation='relu', alpha=0.001, epochs=10, batch_size=32):
        self.hidden_layer_sizes = hidden_layer_sizes
        self.activation = activation
        self.alpha = alpha
        self.epochs = epochs
        self.batch_size = batch_size

    def _create_model(self):
        layers = []
        input_dim = self.input_dim
        activation_fn = {'relu': torch.relu, 'tanh': torch.tanh}[self.activation]
        
        for size in self.hidden_layer_sizes:
            layers.append(nn.Linear(input_dim, size))
            layers.append(nn.ReLU() if activation_fn == torch.relu else nn.Tanh())
            input_dim = size
        layers.append(nn.Linear(input_dim, 1))
        
        self.model = nn.Sequential(*layers)
        self.optimizer = optim.Adam(self.model.parameters(), lr=self.alpha)
        self.criterion = nn.MSELoss()

    def fit(self, X, y):
        # Convert DataFrames to NumPy arrays
        if isinstance(X, pd.DataFrame):
            X = X.values
        if isinstance(y, pd.Series):
            y = y.values
        print(type(X),type(y))
        self.input_dim = X.shape[1]
        self._create_model()
        
        X_tensor = torch.tensor(X, dtype=torch.float32)
        y_tensor = torch.tensor(y, dtype=torch.float32).view(-1, 1)
        
        dataset = torch.utils.data.TensorDataset(X_tensor, y_tensor)
        dataloader = torch.utils.data.DataLoader(dataset, batch_size=self.batch_size, shuffle=True)
        
        self.model.train()
        for epoch in range(self.epochs):
            for batch_X, batch_y in dataloader:
                self.optimizer.zero_grad()
                outputs = self.model(batch_X)
                loss = self.criterion(outputs, batch_y)
                loss.backward()
                self.optimizer.step()
        
        return self

    def predict(self, X):
        if isinstance(X, pd.DataFrame):
            X = X.values
        self.model.eval()
        X_tensor = torch.tensor(X, dtype=torch.float32)
        with torch.no_grad():
            predictions = self.model(X_tensor).numpy()
        return predictions.flatten()
